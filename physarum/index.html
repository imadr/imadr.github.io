<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title></title>
</head>
<body>
<canvas style="width:500px; height:500px;" id="canvas"></canvas>
<script src="../js/webgl_helper.js"></script>
<script src="../js/math.js"></script>
<script>
let canvas = document.getElementById("canvas");
let gl = canvas.getContext("webgl2", {preserveDrawingBuffer: true});
canvas.width = 300;
canvas.height = 300;

let shader_update_particles = create_shader(gl, `#version 300 es
#define PI 3.1415926538

uniform sampler2D u_texture;
uniform uint time;
uniform float particle_speed;
uniform float sensor_dist;
uniform int sensor_size;
uniform float turn_speed;

layout(location = 0) in vec2 position_attrib;
layout(location = 1) in float rotation_attrib;

out vec2 new_position;
out float new_rotation;

uint hash(uint state){
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

float sense(float sensor_angle){
    sensor_angle += rotation_attrib;
    vec2 sensor_dir = vec2(cos(sensor_angle), sin(sensor_angle));
    vec2 sensor_pos = position_attrib+sensor_dir*sensor_dist;

    float sum = 0.0;
    for(int i = -3; i < 3; i++){
        for(int j = -3; j < 3; j++){
            vec2 pos = sensor_pos+vec2(i, j);
            sum += texture(u_texture, pos).x;
        }
    }
    return sum;
}

void main(){
    float rand = float(hash(uint(position_attrib.x)+uint(position_attrib.y)+hash(uint(time))))/4294967295.0;

    new_rotation = rotation_attrib;

    float sense_forward = sense(0.0);
    float sense_left = sense(PI/4.0);
    float sense_right = sense(-PI/4.0);

    float turn_speed_ = turn_speed*2.0*PI;

    if(sense_forward > sense_left && sense_forward > sense_right){
        new_rotation += 0.0;
    }
    else if(sense_forward < sense_left && sense_forward < sense_right){
        new_rotation += (rand-0.5)*2.0*turn_speed_;
    }
    else if(sense_right > sense_left){
        new_rotation -= rand*turn_speed_;
    }
    else if(sense_left > sense_right){
        new_rotation += rand*turn_speed_;
    }

    vec2 direction = vec2(cos(new_rotation), sin(new_rotation));
    new_position = position_attrib+direction*particle_speed;

    if(distance(new_position, vec2(0, 0)) >= 0.99){
        new_rotation = rand*2.0*PI;
        new_position = position_attrib;
    }
}`,
`#version 300 es
    precision highp float;
    void main() {
}`, ["new_position", "new_rotation"]);

let shader_draw_particles = create_shader(gl, `#version 300 es

layout(location = 0) in vec2 position_attrib;
layout(location = 1) in float rotation_attrib;

void main(){
    gl_Position = vec4(position_attrib, 0, 1);
}`,
`#version 300 es
precision highp float;

out vec4 frag_color;

void main(){
    frag_color = vec4(1);
}`);

let shader_fb = create_shader(gl, `#version 300 es

layout(location = 0) in vec3 position_attrib;
layout(location = 1) in vec2 uv_attrib;

out vec3 position;
out vec2 uv;

void main(){
    gl_Position = vec4(position_attrib, 1);
    position = position_attrib;
    uv = uv_attrib;
}`,
`#version 300 es
precision highp float;

uniform sampler2D u_texture;
uniform float diffusion_speed;
uniform float evaporation_speed;
uniform float width;

out vec4 frag_color;

in vec3 position;
in vec2 uv;

void main(){
    float original = texture(u_texture, uv).x;
    float sum = 0.0;
    float pixel_size = 1.0/width;
    for(int offset_x = -1; offset_x <= 1; offset_x++){
        for(int offset_y = -1; offset_y <= 1; offset_y++){
            float sample_x = uv.x+float(offset_x)*pixel_size;
            float sample_y = uv.y+float(offset_y)*pixel_size;
            if(sample_x >= 0.0 && sample_x < 1.0 && sample_y >= 0.0 && sample_y < 1.0){
                sum += texture(u_texture, vec2(sample_x, sample_y)).x;
            }
        }
    }
    float blur = sum/9.0;
    float diffuse = mix(original, blur, diffusion_speed);
    float evaporate = max(0.0, diffuse-evaporation_speed);
    frag_color = vec4(vec3(evaporate), 1);
}`);

let center = [canvas.width/2, canvas.height/2];

let particle_speed = 0.005;
let diffusion_speed = 0.1;
let evaporation_speed = 0.008;
let particles_count = 3000;
let sensor_dist = (1/canvas.width)*3;
let sensor_size = 3;
let turn_speed = 0.1;

let particles_start = [];
for(let i = 0; i < particles_count; i++){
    let r = Math.random()/1;
    let angle = Math.random()*2*Math.PI;
    let pos = vec2_add([0.5, 0.5], [r*Math.cos(angle), r*Math.sin(angle)]);
    particles_start = particles_start.concat([pos[0]-0.5, pos[1]-0.5, Math.random()*Math.PI*2]);
}

let particles_buffer = create_vertex_buffer(gl, particles_start, [
    { name: "position_attrib", size: 2 },
    { name: "rotation_attrib", size: 1 },
], shader_update_particles, false);

let particles_buffer2 = create_vertex_buffer(gl, particles_start, [
    { name: "position_attrib", size: 2 },
    { name: "rotation_attrib", size: 1 },
], shader_update_particles, false);

let transform_feedback = create_transform_feedback(gl, particles_buffer.vbo);
let transform_feedback2 = create_transform_feedback(gl, particles_buffer2.vbo);

let screen_buffer = create_vertex_buffer(gl, [
    -1, -1, 0, 0, 0,
    -1, 1, 0, 0, 1,
    1, -1, 0, 1, 0,
    1, 1, 0, 1, 1,
], [
    { name: "position_attrib", size: 3 },
    { name: "uv_attrib", size: 2 },
], shader_fb, true, [0, 1, 2, 1, 2, 3]);

let texture = create_texture(gl, null, canvas.width, canvas.height, gl.NEAREST);
let texture2 = create_texture(gl, null, canvas.width, canvas.height, gl.NEAREST);
let framebuffer = create_framebuffer(gl, texture);

gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
gl.clearColor(0, 0, 0, 1);
gl.clear(gl.COLOR_BUFFER_BIT);
gl.bindTexture(gl.TEXTURE_2D, texture2);
gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, canvas.width, canvas.height, 0);
let time = 0;
function draw(){
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.useProgram(shader_update_particles.program);
    gl.bindTexture(gl.TEXTURE_2D, texture2);
    set_shader_uniform(gl, shader_update_particles, "time", time);
    set_shader_uniform(gl, shader_update_particles, "particle_speed", particle_speed);
    set_shader_uniform(gl, shader_update_particles, "sensor_dist", sensor_dist);
    set_shader_uniform(gl, shader_update_particles, "sensor_size", sensor_size);
    set_shader_uniform(gl, shader_update_particles, "turn_speed", turn_speed);
    gl.bindVertexArray(particles_buffer.vao);
    gl.enable(gl.RASTERIZER_DISCARD);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transform_feedback2);
    gl.beginTransformFeedback(gl.POINTS);
    gl.drawArrays(gl.POINTS, 0, particles_count);
    gl.endTransformFeedback();
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    gl.disable(gl.RASTERIZER_DISCARD);

    gl.useProgram(shader_draw_particles.program);
    draw_buffer(gl, particles_buffer, gl.POINTS);

    let tmp = particles_buffer;
    particles_buffer = particles_buffer2;
    particles_buffer2 = tmp;
    tmp = transform_feedback;
    transform_feedback = transform_feedback2;
    transform_feedback2 = tmp;

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.useProgram(shader_fb.program);
    set_shader_uniform(gl, shader_fb, "diffusion_speed", diffusion_speed);
    set_shader_uniform(gl, shader_fb, "evaporation_speed", evaporation_speed);
    set_shader_uniform(gl, shader_fb, "width", canvas.width);
    draw_buffer(gl, screen_buffer, gl.TRIANGLES);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, canvas.width, canvas.height, 0);
    gl.bindTexture(gl.TEXTURE_2D, texture2);
    gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, canvas.width, canvas.height, 0);

    time++;
    window.requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>