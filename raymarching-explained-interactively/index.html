<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Raymarching explained interactively</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <script src="/js/highlight.js"></script>
    <style>
        canvas{
            padding-left: 0;
            padding-right: 0;
            margin-left: auto;
            margin-right: auto;
            display: block;
        }
        .red{
            background-color: #ea3333;
        }
        .green{
            background-color: #29c643;
        }
        .blue{
            background-color: #2c66c9;
        }
        .orange{
            background-color: #ff8f00;
        }
        .rounded-bg{
            border-radius: 3px;
            padding: 1px 5px 1px 5px;
            color: white;
            font-family: "mono";
            font-weight: bold;
        }
        .super{
            vertical-align: super;
            font-size: 13px;
            margin-right: 3px;
        }
        .equation{
            font-family: "mono";
            font-weight: bold;
            border: none;
            margin-right: auto;
            margin-left: auto;
        }
        .equation td{
            padding-bottom: 12px;
        }
        .equation td, .equation tr{
            border: none;
        }
        .sqrt-before-before{
            content: "";
            width: 5px;
            height: 30%;
            position: absolute;
            border-right: 2px solid;
            border-top: none;
            left: 0px;
            bottom: 10px;
            transform: skew(20deg);
        }
        .sqrt-before{
            content: "";
            width: 5px;
            height: 80%;
            position: absolute;
            border-right: 2px solid;
            border-top: none;
            left: 4px;
            top: -3px;
            transform: skew(-8deg);
        }
        .sqrt{
            padding-left: 10px;
            position: relative;
        }
        .sqrt-overline{
            border-top: 2px solid var(--color-fg-1);
            padding-top: 5px;
            padding-left: 5px;
        }
        .norm{
            letter-spacing: -5px;
            padding-right: 5px;
        }
    </style>
</head>
<body>
    <nav>
        <a href="/" style="text-transform: uppercase;">Imadr.me</a>
        <span id="navbar-right" style="float: right;">
            <a href="/">About</a>
            <a href="/">Projects</a>
            <a href="/">Blog</a>
        </span>
    </nav>

    <h1>Raymarching explained interactively</h1>

    <h2 id="introduction"><a href="#introduction">Introduction</a></h2>
    <p>
        Raymarching is a 3D rendering technique popular in the <a href="https://en.wikipedia.org/wiki/Demoscene">demoscene</a> and in websites like <a href="https://www.shadertoy.com/">Shadertoy</a>.<br>
        What's impressive about demos is that there is <strong>no 3D geometry whatsoever</strong>. All the objects that make up the scene are generated in real time using mathematical functions.
    </p>
    <p>
        My all-time favorite demo is <a href="https://www.youtube.com/watch?v=JZ6ZzJeWgpY">"fermi paradox" by mercury</a>. This youtube video weights tens of megabytes, but thanks to raymarching (and other clever techniques like compression and procedural generation) the demo executable itself is only 64 kilobytes.<br>
    </p>
    <p>In this interactive tutorial, we will see how the raymarching algorithm works.</p>
    <!-- <p>
        A fragment shader is a program that is executed in the graphics card. Usually in 3D applications like video games, two types of shaders are used: the <strong>vertex shader</strong>, which is executed once every frame for each point of each 3D model in the scene, and the fragment shader, which is executed for each pixel of the screen.
    </p>
 -->
    <h2 id="signed-distance-function"><a href="#signed-distance-function">Signed distance function</a></h2>

    <p>The raymarching algorithm is based on the notion of distances, we will see how later.</p>

    <p>You may be familiar with the formula for the distance between two points, it is known as the <strong>Euclidean distance</strong> and is calculated using the Pythagorean theorem:</p>

    <table class="equation">
        <tr>
            <td>
                EuclideanDistance(<span class="rounded-bg blue">P1</span>,<span class="rounded-bg green">P2</span>)
            </td>
            <td>=</td>
            <td class="sqrt">
                <span class="sqrt-before-before"></span>
                <span class="sqrt-before"></span>
                <span class="sqrt-overline">
                    (<span class="rounded-bg blue">P1.x</span>-<span class="rounded-bg green">P2.x</span>)<span class="super">2</span>+(<span class="rounded-bg blue">P1.y</span>-<span class="rounded-bg green">P2.y</span>)<span class="super">2</span>
                </span>
            </td>
        </tr>
        <tr>
            <td></td>
            <td>=</td>
            <td><span class="rounded-bg red" id="euclidean-distance"></span></td>
        </tr>
    </table>

    <br>
    <canvas id="canvas-euclidean-distance"></canvas>

    <p>Now imagine we want to calculate the distance between a point and a circle. To do that we first calculate the euclidean distance between the point and the center of the circle, then substract the radius of the circle:</p>
    <table class="equation">
        <tr>
            <td>
                DistanceToCircle(<span class="rounded-bg blue">P</span>,<span class="rounded-bg green">C</span>,<span class="rounded-bg orange">R</span>)
            </td>
            <td>=</td>
            <td>
                EuclideanDistance(<span class="rounded-bg blue">P</span>,<span class="rounded-bg green">C</span>)-<span class="rounded-bg orange">R</span>
            </td>
        </tr>
        <tr>
            <td></td>
            <td>=</td>
            <td><span id="circle-distance" class="rounded-bg red"></td>
        </tr>
    </table>
    <canvas id="canvas-circle-sdf"></canvas>
    <p>Notice that when the point is inside the circle, the distance is negativeâ€”hence "signed" distance function. This fact will become useful later on.</p>
    <p>The <strong>SDF of an object</strong> is a function that, given a point in space as input, outputs the distance from that point to the closest point of the object.</p>

    <p>The SDF of rectangle is a little bit more complicated</p>

     <table class="equation">
        <tr>
            <td>
                DistanceToRect(<span class="rounded-bg blue">P</span>,<span class="rounded-bg green">C</span>,<span class="rounded-bg orange">Size</span>)
            </td>
            <td>=</td>
            <td><span class="norm">||</span>max(|<span class="rounded-bg blue">P</span>-<span class="rounded-bg green">C</span>|-(<span class="rounded-bg orange">Size</span>/2),0)<span class="norm">||</span></td>
        </tr>
        <tr>
            <td></td>
            <td>=</td>
            <td><span id="rect-distance" class="rounded-bg red"></span></td>
        </tr>
    </table>

    <canvas id="canvas-rect-sdf"></canvas>

    <p>If we have multiple shapes and we want to find the closets point to <span class="rounded-bg blue">P</span>, we calculate the <strong>minimum</strong> of all the SDFs of the shapes:</p>
    <canvas id="canvas-shapes-sdf"></canvas>

    <h2 id="the-raymarching-algorithm"><a href="#the-raymarching-algorithm">The Raymarching algorithm</a></h2>

    <p>Why distances have anything to do with rendering 3D shapes? </p>

    <canvas id="canvas-raymarching-1"></canvas>
    <br>
    Near plane: <input style="vertical-align: middle;" type="range" value="60" min="10" max="100" step="1" id="near-plan" autocomplete="off"><br>
    Field of view: <input style="vertical-align: middle;" type="range" value="30" min="5" max="80" step="1" id="fov" autocomplete="off"><br>
    Number of rays: <input style="vertical-align: middle;" type="range" value="20" min="2" max="100" step="1" id="nb-rays" autocomplete="off"><br>
    <button id="raymarching-play">Play</button>Iterations: <input style="vertical-align: middle;" type="range" value="5" min="0" max="10" step="1" id="iterations" autocomplete="off"><br>

    <canvas id="canvas-raymarching-2"></canvas>

    <h2 id="going-3d"><a href="#going-3d">Going 3D</a></h2>
    <p>Until now we only saw how raymarching works in two dimensions, to do 3D rendering we are going to use a <strong>fragment shader</strong></p>
    <canvas id="canvas-webgl-1"></canvas>
    <canvas id="canvas-webgl-2"></canvas>
    <canvas id="canvas-webgl-3"></canvas>

    <h2 id="further-reading"><a href="#further-reading">Futher reading</a></h2>
    <ul>
        <li><a href="https://www.iquilezles.org/www/index.htm">Inigo Quilez</a> is the best resource on raymarching.</li>
    </ul>

    <!-- <code><pre>function march(ray_origin, ray_direction){
    total_distance = 0
    for(i = 0; i < max_iterations; i++){
        distance = sdf()
        total_distance += distance

        if(distance < small_number){
            break
        }
        if(total_distance > big_number){
            break
        }
    }
    return total_distance
}</pre></code>
 -->

<script src="/js/webgl_helper.js"></script>
<script src="/js/math.js"></script>
<script src="/js/light.js"></script>
<script src="main.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function(e){
    document.querySelectorAll(".code").forEach(function(block){
        hljs.highlightBlock(block);
    });
});
</script>
</body>
</html>