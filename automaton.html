<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Cellular automaton</title>
    <link rel="stylesheet" href="css/style.css">
    <link id="css" rel="stylesheet" href="css/light.css">
    <style>
    body{
        overflow: hidden;
        max-width: inherit;
        width: 100%;
        margin: 0;
        padding: 0;
    }
    #canvas{
        position: absolute;
        top: 0px;
        left: 0px;
        z-index: 0;
    }
    #option{
        z-index: 1;
        position: absolute;
        display: inline-block;
        top: 10px;
        left: 10px;
        background-color: white;
        border: 1px solid black;
        padding: 10px;
    }
    #show_button{
        position: absolute;
        top: 10px;
        left: 10px;
    }
    .small_input{
        width: 30px;
        text-align: center;
    }
    br{
        margin-bottom: 8px;
    }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="option">
    <button id="hide_button">Hide</button>
    <br>
    <button id="pause_button">Pause</button> <button id="step_button">Step</button> ms: <input type="number" id="input_ms" class="small_input" min="1">
    <br>
    <button id="clear_button">Clear</button>
    <br>
    Grid size: <input type="number" id="input_grid_size_x" class="small_input" min="1"> x <input type="number" id="input_grid_size_y" class="small_input" min="1">
    <br>
    <div id="logs"></div>
</div>
<button class="invisible" id="show_button">â–º</button>
<script>
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");

class Automaton{
    constructor(dimension, grid_size, states, neighborhood, transition, boundary){
        this.dimension = dimension;
        this.grid_size = grid_size;
        this.states = states;
        this.neighborhood = neighborhood;
        this.transition = transition;
        this.boundary = boundary;
        this.init_grid();
    }
    init_grid(){
        if(this.dimension == 1){
            this.grid = [];
            for(var i = 0; i < this.grid_size; i++){
                this.grid[i] = 0;
            }
        }
        else if(this.dimension == 2){
            this.grid = [];
            for(var i = 0; i < this.grid_size[0]; i++){
                this.grid[i] = [];
                for(var j = 0; j < this.grid_size[1]; j++){
                    this.grid[i][j] = 0;
                }
            }
        }
    }
    neighbours(x, y){
        var n = 0;
        for(var i = 0; i < this.neighborhood.length; i++){
            var pos = [x+this.neighborhood[i][0], y+this.neighborhood[i][1]];
            if(pos[0] == this.grid_size[0]) pos[0] = 0;
            if(pos[0] == -1) pos[0] = this.grid_size[0]-1;
            if(pos[1] == this.grid_size[1]) pos[1] = 0;
            if(pos[1] == -1) pos[1] = this.grid_size[1]-1;
            n += this.states[this.grid[pos[0]][pos[1]]][0];
        }
        return n;
    }
    cell_transition(state, ...coords){
        var new_state;

        if(this.dimension == 1){
            var s = "";
            if(state == 0){
                s += this.grid[this.grid.length-1]+"";
            }
            else{
                s += this.grid[state-1]+"";
            }
            s += this.grid[state]+"";
            if(state == this.grid.length-1){
                s += this.grid[0]+"";
            }
            else{
                s += this.grid[state+1]+"";
            }
            for(var i = 0; i < this.transition.length; i++){
                if(s == this.transition[i][0]){
                    return this.transition[i][1];
                }
            }
        }
        else if(this.dimension == 2){
            for(var i = 0; i < this.transition.length; i++){
                if(this.transition[i][0] == state && this.transition[i][1].indexOf(this.neighbours(...coords)) > -1){
                    new_state = this.transition[i][2];
                    return new_state;
                }
            }
        }
        return state;
    }
    next_gen(){
        if(this.dimension == 1){
            var new_gen = [];
            for(var i = 0; i < this.grid_size; i++){
                new_gen[i] = this.cell_transition(i);
            }
            this.grid = new_gen;
        }
        else if(this.dimension == 2){
            var new_gen = [];
            for(var i = 0; i < this.grid_size[0]; i++){
                new_gen[i] = [];
                for(var j = 0; j < this.grid_size[1]; j++){
                    new_gen[i][j] = this.cell_transition(this.grid[i][j], i, j);
                }
            }
            this.grid = new_gen;
        }
    }
}

var moore_neighbourhood = [[0, 1], [0, -1], [-1, 0], [-1, -1], [-1, 1], [1, 0], [1, -1], [1, 1]];
var game_of_life = [[0, [1, 2, 3, 4], 1], [1, [8], 1], [1, [1, 2, 3, 4, 5, 6, 7], 0]];
var automaton = new Automaton(2, [100, 100], [[0, "#FFFFFF"], [1, "#000000"]], moore_neighbourhood, game_of_life);
//var rule_30 = [["111", 0], ["110", 0], ["101", 0], ["100", 1], ["011", 1], ["010", 1], ["001", 1], ["000", 0]]
//var automaton = new Automaton(1, 20, [[0, "#FFFFFF"], [1, "#000000"]], null, rule_30);

var offset = [0, 0];
var ms = 100;
var cell_size = 10;
var hover_cell = [-1, -1];

var paused = false;
var step = false;
var anim_request;
var time;
var mouse_dragging = false;
var start_drag = [0, 0];
var offset_drag = [0, 0];

window.addEventListener("resize", init);
document.body.addEventListener("mousemove", mousemove);
document.body.addEventListener("mousedown", mousedown);
document.body.addEventListener("mouseup", mouseup);
document.body.addEventListener("wheel", zoom);

get("pause_button").addEventListener("click", function(){
    paused = !paused;
    this.innerHTML = this.innerHTML == "Pause" ? "Play" : "Pause";
});
get("step_button").addEventListener("click", function(){
    paused = true;
    step = true;
    get("pause_button").innerHTML = "Play";
});
get("hide_button").addEventListener("click", function(){
    get("option").classList.toggle("invisible");
    get("show_button").classList.toggle("invisible");
});
get("show_button").addEventListener("click", function(){
    get("option").classList.toggle("invisible");
    get("show_button").classList.toggle("invisible");
});
get("clear_button").addEventListener("click", function(){
    automaton.init_grid();
});

var inputs = [
    ["input_grid_size_x", "array", ["automaton", "grid_size"], 0, "int", ["init"]],
    ["input_grid_size_y", "array", ["automaton", "grid_size"], 1, "int", ["init"]],
    ["input_ms", "notarray", ["ms"], 0, "int", []],
];
for(var i = 0; i < inputs.length; i++){
    (function(i){
        var thing = window;
        if(inputs[i][2].length > 1){
            for(var j = 0; j < inputs[i][2].length; j++){
                thing = thing[inputs[i][2][j]];
            }
        }
        else{
            thing = window[inputs[i][2][0]];
        }
        if(inputs[i][1] == "array"){
            get(inputs[i][0]).value = thing[inputs[i][3]];
        }
        else{
            get(inputs[i][0]).value = thing;
        }
        get(inputs[i][0]).addEventListener("input", function(){
            if(this.checkValidity()){
                var val = this.value;
                if(inputs[i][4] == "int"){
                    val = parseInt(val);
                }
                if(inputs[i][1] == "array"){
                    thing[inputs[i][3]] = val;
                }
                else{
                    window[inputs[i][2][0]] = val;
                }
                var fns = inputs[i][5];
                for(var j = 0; j < fns.length; j++){
                    window[fns[j]]();
                }
            }
        });
    }(i));
}

init();

function get(i){
    return document.getElementById(i);
}

function zoom(e){
    if(event.deltaY > 0){
        if(cell_size > 1) cell_size--;
    }
    else{
        if(cell_size < 50) cell_size++;
    }
    center_offset();
}

function mousemove(e){
    hover_cell[0] = Math.floor((e.clientX-offset[0])/cell_size);
    hover_cell[1] = Math.floor((e.clientY-offset[1])/cell_size);
    if(mouse_dragging){
        offset_drag[0] = start_drag[0]-e.clientX;
        offset_drag[1] = start_drag[1]-e.clientY;
        center_offset();
    }
}

function mousedown(e){
    if(e.target != canvas){
        return;
    }
    if(e.which == 1){
        var x = Math.floor((e.clientX-offset[0])/cell_size);
        var y = Math.floor((e.clientY-offset[1])/cell_size);
        if(automaton.grid[x] !== undefined && automaton.grid[x][y] !== undefined) automaton.grid[x][y] = automaton.grid[x][y] == 0 ? 1 : 0;
    }
    if(e.which == 2){
        start_drag = [e.clientX+offset_drag[0], e.clientY+offset_drag[1]];
        mouse_dragging = true;
    }
}

function mouseup(e){
    if(e.which == 2){
        mouse_dragging = false;
    }
}

function update(){
    anim_request = window.requestAnimationFrame(update);
    if((!paused || step) && Date.now()-time > ms){
        step = false;
        time = Date.now();
        automaton.next_gen();
    }
    draw();
}

function draw(){
    ctx.fillStyle = automaton.states[0][1];
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if(automaton.dimension == 1){
        /*for(var i = 0; i < automaton.grid_size; i++){
            if(automaton.grid[i] >= 1){
                ctx.fillStyle = automaton.states[automaton.grid[i]][1];
                ctx.fillRect(i*cell_size+offset[0], 1*cell_size+offset[1], cell_size, cell_size);
            }
            if(automaton.grid[i] >= 1 || (i == hover_cell[0])){
                ctx.fillRect(i*cell_size+offset[0], j*cell_size+offset[1], cell_size, cell_size);
            }
                if(i == hover_cell[0] && j == hover_cell[1]){
                    ctx.lineWidth = 2;
                    ctx.fillStyle = automaton.states[automaton.grid[i][j]][1];
                    ctx.fillRect(i*cell_size+offset[0], j*cell_size+offset[1], cell_size, cell_size);
                    ctx.strokeRect(i*cell_size+offset[0], j*cell_size+offset[1], cell_size, cell_size);
                }
            }
        }
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.moveTo(offset[0], offset[1]);
        ctx.lineTo(automaton.grid_size*cell_size+offset[0], offset[1]);
        ctx.lineTo(automaton.grid_size*cell_size+offset[0], cell_size+offset[1]);
        ctx.lineTo(offset[0], cell_size+offset[1]);
        ctx.lineTo(500, 500);
        ctx.stroke();*/
    }
    else if(automaton.dimension == 2){
        for(var i = 0; i < automaton.grid_size[0]; i++){
            for(var j = 0; j < automaton.grid_size[1]; j++){
                if(automaton.grid[i][j] >= 1){
                    ctx.fillStyle = automaton.states[automaton.grid[i][j]][1];
                }
                if(automaton.grid[i][j] >= 1 || (i == hover_cell[0] && j == hover_cell[1])){
                    ctx.fillRect(i*cell_size+offset[0], j*cell_size+offset[1], cell_size, cell_size);
                }
                if(i == hover_cell[0] && j == hover_cell[1]){
                    ctx.lineWidth = 2;
                    ctx.fillStyle = automaton.states[automaton.grid[i][j]][1];
                    ctx.fillRect(i*cell_size+offset[0], j*cell_size+offset[1], cell_size, cell_size);
                    ctx.strokeRect(i*cell_size+offset[0], j*cell_size+offset[1], cell_size, cell_size);
                }
            }
        }
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.moveTo(offset[0], offset[1]);
        ctx.lineTo(automaton.grid_size[0]*cell_size+offset[0], offset[1]);
        ctx.lineTo(automaton.grid_size[0]*cell_size+offset[0], automaton.grid_size[1]*cell_size+offset[1]);
        ctx.lineTo(offset[0], automaton.grid_size[1]*cell_size+offset[1]);
        ctx.lineTo(offset[0], offset[1]);
        ctx.stroke();
    }
}

function center_offset(zoom){
    offset = [canvas.width/2-(automaton.grid_size[0]*cell_size)/2-offset_drag[0], canvas.height/2-(automaton.grid_size[1]*cell_size)/2-offset_drag[1]];
}

function init(){
    cancelAnimationFrame(anim_request);
    canvas.width = document.documentElement.clientWidth;
    canvas.height = document.documentElement.clientHeight;
    center_offset();
    time = Date.now();
    automaton.init_grid();
    update();
}
</script>
</body>
</html>